suricatta documentation
========================
Andrey Antukh, <niwi@niwi.be>
0.1.0-SNAPSHOT
:toc: left
:numbered:
:source-highlighter: pygments
:pygments-style: friendly


Introduction
------------

_suricatta_ is a high level sql toolkit for clojure (backed by fantastic link:http://www.jooq.org/[jooq library])

It consists in two main modules:

- sql executor: jdbc abstraction layer for executing queries.
- sql builder: small dsl for idiomatic sql building using clojure code.
- sql formatter: utils for format in string or sqlvec queryes builded by `sql builder` module.


Why I should use it?
~~~~~~~~~~~~~~~~~~~~

Unlike _clojure.jdbc_, this library/toolkit works in slightly higher level than
jdbc libraries, and it hides a lot of idiosyncrasies of jdbc under much simpler, cleaner
and less error prone api.

It also, has clear diferentiation between queries that can return results and that cannot, and
much better resource and memmory management with result sets and prepared statements.


Use cases
~~~~~~~~~

_suricatta_ library is very flexible and it can be used in very different ways:

- Build queries with _suricatta_ and execute them with _clojure.jdbc_ (it has good interoperability)
- Execute queries with _suricatta_ and use raw string queries or any other sql building library.
- Combine usage of _clojure.jdbc_ and _suricatta_ in one code base (you can create suricatta context
  from existing jdbc connection).


Project Maturity
----------------

Since _suricatta_ is a young project there may be some API breakage.

Install
-------

This section covers a installing _suricatta_ and its requirements.

Requirements
~~~~~~~~~~~~

_suricatta_ is tested with these platforms:

- JDK7
- JDK8


Leiningen
~~~~~~~~~

The simplest way to use _suricatta_ in a clojure project, is by including it in the dependency
vector on your *_project.clj_* file:

._on project.clj_
[source,clojure]
----
[suricatta "0.1.0-SNAPSHOT"]
----

Gradle
~~~~~~

If you are using gradle, this is a dependency line for gradle dsl:

[source,groovy]
----
compile "suricatta:suricatta:0.1.0-SNAPSHOT"
----

Maven
~~~~~

And for old school people, who are using a ugly XML files to configure everything,
this is a XML block that you should put in a dependency section of a maven config file:

.Repository entry.
[source,xml]
----
<repository>
    <id>clojars.org</id>
    <url>http://clojars.org/repo</url>
</repository>
----

.Dependency entry.
[source,xml]
----
<dependency>
  <groupId>suricatta</groupId>
  <artifactId>suricatta</artifactId>
  <version>0.1.0-SNAPSHOT</version>
</dependency>
----


Get the Code
~~~~~~~~~~~~

_suricatta_ is open source and is entirely developed on
link:https://github.com/niwibe/suricatta[github].

You can clone the public repository with this command:

[source,text]
----
git clone https://github.com/niwibe/suricatta
----


SQL Execution
-------------

This section intends to explain the usage of sql execution part of the library.


Connecting to database
~~~~~~~~~~~~~~~~~~~~~~

_surricata_ uses the concept of **context** instead of **connection** unlike any other database
libraries. The **context** has the resposibility of connection resource management,
transaction isolation flags and sql rendering dialect.

You can create one **context** from:

- Plain jdbc connection.
- link:http://niwibe.github.io/clojure.jdbc[clojure.jdbc] connection object
- `dbspec` hash-map (same format that link:http://niwibe.github.io/clojure.jdbc/#_connecting_to_database[clojure.jdbc] accepts, including with datasource)

Let see some examples:

.Creating context from _dbspec_
[source, clojure]
----
(require '[suricatta.core :as sc])

(with-open [ctx (sc/context {:subprotocol "h2"
                             :subname "mem:"})]
  (do-something-with ctx))
----

.Create context from existing _clojure.jdbc_ connection.
[source, clojure]
----
(require '[jdbc.core :as jdbc])
(require '[suricatta.core :as sc])

(def dbspec {:subprotocol "h2"
             :subname "mem:"})

(jdbc/with-connection [conn dbspec]
  (let [ctx (sc/context conn)
        res (do-something ctx)]
    res))
----

Executing queries
~~~~~~~~~~~~~~~~~

_suricatta_ has clear separation between queries that can return result, and queries that cannot.

With `suricatta.core/query` function you can build queries that does not return results, like _ddl_
operations or any other sql commands.

[source, clojure]
----
(require '[suricatta.core :as sc])

(let [q (sc/query ctx "CREATE TABLE foo")]
  (sc/execute q))
----

The return value of `suricatta.core/execute` function depends on the query.

Exists a convenience method that can avoid one step:

[source, clojure]
----
(require '[suricatta.core :as sc])
(sc/execute ctx "CREATE TABLE foo")
----

Fetching results
~~~~~~~~~~~~~~~~

With `suricatta.core/result-query` you can build `ResultQuery` instance, which has support for
fetching results.

[source, clojure]
----
(require '[suricatta.core :as sc])

(let [q (sc/result-query ctx "select x from generate_series(1,3) as x")]
  (sc/fetch q))
;; => [{:x 1} {:x 2} {:x 3}]
----

Exists a convenience method that can avoid one step:

[source, clojure]
----
(require '[suricatta.core :as sc])
(sc/fetch ctx "select x from generate_series(1,3) as x")
;; => [{:x 1} {:x 2} {:x 3}]
----

[NOTE]
====
_suricatta_ gives you the power of use the raw sql queries without
any restrictions (unlike jdbs). As great example, _suricatta_ does
not have special syntax for queries with `RETURNING` clause:

[source, clojure]
----
(sc/fetch ctx "INSERT INTO foo (name) values ('bar') returning id")
;; => [{:id 27}]
----
====

Parametrized queries
~~~~~~~~~~~~~~~~~~~~

Like _clojure.jdbc_ and _clojure.java.jdbc_, _suricatta_ has support for parametrized
queries in *sqlvec* format.

[source, clojure]
----
(sc/fetch ctx ["select id from books where age > ? limit 1" 100])
;; => [{:id 4232}]
----

Transactions
~~~~~~~~~~~~

_suricatta_ does not have support for low level usage of transactions, instead of it, offers
lightweight abstraction: `atomic` high order function and `with-atomic` convenient macro.

.Execute some query in a transaction block
[source, clojure]
----
(sc/atomic ctx (fn [ctx]
                 (sc/fetch ctx "select id, name from book for update")))
----

Additionally to `atomic` high order functiom, _suricatta_ comes with convenient macro offering
lightweight sugar sytax for atomic blocks:

[source, clojure]
----
(cs/with-atomic ctx
  (sc/fetch ctx "select id, name from book for update"))
----

If something happens inside atomic wrapped function, the transaction will be aborted.

[NOTE]
You can nest atomic usage as deep as you want, _suricatta_ (thanks to jooq) has good support
for subtransactions (savepoints).


Lazy result fetching
~~~~~~~~~~~~~~~~~~~~

Not implemented yet.


Batch execution
~~~~~~~~~~~~~~~

Not implemented yet.


SQL Building and Formatting
---------------------------

This section intends to explain the usage of sql building library, the lightweight layer on
top of `jooq` dsl.

You can found all related functions of sql dsl on `suricatta.dsl` namespace:

[source, clojure]
----
(require '[suricatta.dsl :as dsl])
----

And functions related to formating sql into string or sqlvec format in `suricatta.format` namespace:

[source, clojure]
----
(require '[suricatta.format :as fmt])
----

The SELECT statement
~~~~~~~~~~~~~~~~~~~~

Select clause
^^^^^^^^^^^^^

Simple select clause without from part:

[source, clojure]
----
(dsl/select :id :name)
----

Would generate SQL like this:

[source,sql]
----
select id, name from dual
----

The rendering result depends of used dialect. You can specify an other dialect
passing `:dialect` option to `get-sql` function of `suricatta.format` namespace:

[source, clojure]
----
(-> (dsl/select :id :name)
    (fmt/get-sql {:dialect :postgresql}))
;; => "select id, name"
----


Select DISTINCT
^^^^^^^^^^^^^^^

You can add distinct keyword using special select function:

[source, clojure]
----
(-> (dsl/select-distinct :name)
    (fmt/get-sql))
;; => "select distinct name"
----


Select *
^^^^^^^^

You can ommit fields on `select` function for use the "SELECT *" form:

[source, clojure]
----
(-> (dsl/select)
    (dsl/from :book)
    (fmt/get-sql))
;; => "select * from book"
----


The FROM clause
^^^^^^^^^^^^^^^

Simple select sql with form clause:

[source, clojure]
----
(-> (dsl/select :book.id :book.name)
    (dsl/from :book)
    (fmt/get-sql))
;; => "select book.id, book.name from book"
----

Also, sql form clause supports specify any number of tables:

[source, clojure]
----
(-> (dsl/select-one)
    (dsl/from :book :article)
    (fmt/get-sql))
;; => "select 1 from book, article"
----

Also, you can specify alias for each table:

[source, clojure]
----
(-> (dsl/select-one)
    (dsl/from (dsl/table "book" :alias "a")
              (dsl/table "article" :alias "b"))
    (fmt/get-sql))
;; => "select 1 from book \"a\", article \"b\""
----


The JOIN clause
^^^^^^^^^^^^^^^

_suricata_ comes with complete dsl for making join clauses. Let see one simple example:

[source, clojure]
----
(-> (dsl/select :name)
    (dsl/from :book)
    (dsl/join :author)
    (dsl/on "book.author_id = book.id")
    (fmt/get-sql))
;; => "select name from book join author on (book.author_id = book.id)"
----

Also, join clause can be applied to table expression:

[source, clojure]
----
(-> (dsl/select :name)
    (dsl/from (-> (dsl/table "book")
                  (dsl/join "author")
                  (dsl/on "book.author_id = book.id")))
    (fmt/get-sql))
;; => "select name from book join author on (book.author_id = book.id)"
----


The WHERE clause
^^^^^^^^^^^^^^^^

The WHERE clause can be used for JOIN or filter predicates, in order to restrict the data returned
by the query:

[source, clojure]
----
(-> (dsl/select :name)
    (dsl/from :book)
    (dsl/where "book.age > 100")
    (fmt/get-sql))
;; => "select name from book where (book.age > 100)"
----

Build where clause with multiple conditions:

[source, clojure]
----
(-> (dsl/select :name)
    (dsl/from :book)
    (dsl/where "book.age > 100"
               "book.in_store = true")
    (fmt/get-sql))
;; => "select name from book where ((book.age > 100) and (book.in_store = true))"
----


Bind parameters instead of inline them on conditions:

[source, clojure]
----
(-> (dsl/select :name)
    (dsl/from :book)
    (dsl/where ["book.age > ?" 100]
               ["book.in_store = ?", true])
    (fmt/sqlvec))
;; => ["select name from book where ((book.age > ?) and (book.in_store = ?))" 100 true]
----

Using explicit logical operators:

[source, clojure]
----
(-> (dsl/select :name)
    (dsl/from :book)
    (dsl/where (dsl/or "book.age > 20"
                       (dsl/not "book.in_store")))
    (fmt/get-sql))
;; => "select name from book where ((book.age > 20) or (not book.in_store))"
----


The GROUP BY clause
^^^^^^^^^^^^^^^^^^^

GROUP BY can be used to create unique groups of data, to form aggregations, to remove duplicates and for other reasons. Let see an example of how it can be done using _suricatta_ dsl:

[source, clojure]
----
(-> (dsl/select (dsl/field "name")
                (dsl/field "count(*)"))
    (dsl/from :book)
    (dsl/group-by :name)
    (fmt/get-sql))
;; => "select name, count(*) from book group by name"
----


The HAVING clause
^^^^^^^^^^^^^^^^^

The HAVING clause is used to further restrict aggregated data. Let see an example:

[source, clojure]
----
(-> (dsl/select (dsl/field "name")
                (dsl/field "count(*)"))
    (dsl/from :book)
    (dsl/group-by :name)
    (dsl/having ["count(*) > ?", 2])
    (fmt/get-sql))
;; => "select name, count(*) from book group by name having (count(*) > ?)"
----

The ORDER BY clause
^^^^^^^^^^^^^^^^^^^

Here an example of how specify the ordering to the query:

.Ordering by field with implicit sort direction
[source, clojure]
----
(-> (dsl/select :name)
    (dsl/from :book)
    (dsl/order-by :name)
    (fmt/get-sql))
;; => "select name from book order by name asc"
----

In previous example we have specified order field without order direction, _surricata_ automatically
uses `ASC` for sort fields that comes without explicit ordering direction.

.Specify sort direction explicitly
[source, clojure]
----
(-> (dsl/select :name)
    (dsl/from :book)
    (dsl/order-by [:name :desc])
    (fmt/get-sql))
;; => "select name from book order by name desc"
----

.Handling nulls
[source, clojure]
----
(-> (dsl/select :name)
    (dsl/from :book)
    (dsl/order-by [:name :desc :nulls-last])
    (fmt/get-sql))
;; => "select name from book order by name desc nulls last"
----

.Ordering by index
[source, clojure]
----
(-> (dsl/select :id :name)
    (dsl/from :book)
    (dsl/order-by ["1" :asc]
                  ["2" :desc])
    (fmt/get-sql))
;; => "select name from book order by 1 asc, 2 desc"
----


The LIMIT and OFFSET clauses
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let see some examples of how to apply limit and offset to your queries with _suricatta_:

[source, clojure]
----
(-> (dsl/select :id :name)
    (dsl/from :book)
    (dsl/limit 10)
    (dsl/offset 100)
    (fmt/get-sql))
;; => "select name from book limit ? offset ?"
----


The FOR UPDATE clause
^^^^^^^^^^^^^^^^^^^^^

For inter-process synchronisation and other reasons, you may choose to use the SELECT .. FOR UPDATE
clause to indicate to the database, that a set of cells or records should be locked by a
given transaction for subsequent updates. Let see an example of how use it with _suricatta_ dsl:

.Without specific fields
[source, clojure]
----
(-> (dsl/select)
    (dsl/from :book)
    (dsl/for-update)
    (fmt/get-sql))
;; => "select * from book for update"
----

.With specific fields
[source, clojure]
----
(-> (dsl/select)
    (dsl/from :book)
    (dsl/for-update :name)
    (fmt/get-sql))
;; => "select * from book for update of \"name\""
----

The UNION and UNION ALL clause
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

These operators combine two results into one. UNION removes all duplicate records resulting from this combination and UNION ALL preserves all results as they are.

.Using UNION clause
[source, clojure]
----
(-> (dsl/union
    (-> (dsl/select :name)
        (dsl/from :books))
    (-> (dsl/select :name)
        (dsl/from :articles)))
    (fmt/get-sql))
;; => "(select name from books) union (select name from articles)"
----

.Using UNION ALL clause
[source, clojure]
----
(-> (dsl/union-all
    (-> (dsl/select :name)
        (dsl/from :books))
    (-> (dsl/select :name)
        (dsl/from :articles)))
    (fmt/get-sql))
;; => "(select name from books) union all (select name from articles)"
----


The INSERT statement
~~~~~~~~~~~~~~~~~~~~

The INSERT statement is used to insert new records into a database table.

.Example of insert two rows in one table.
[source, clojure]
----
(-> (dsl/insert-into :table1 :f1 :f2 :f3)
    (dsl/insert-values 1 2 0)
    (dsl/insert-values 3 4 0)
    (fmt/sqlvec))
;; => ["insert into t1 (f1, f2, f3) values (?, ?, ?), (?, ?, ?)" 1 2 0 3 4 0]
----

WARNING: both `insert-into` and `insert-values` functions are macros and they only accept
literals as parameters.

The UPDATE statement
~~~~~~~~~~~~~~~~~~~~

The UPDATE statement is used to modify one or several pre-existing records in a database table.

.Example of update statement without condition.
[source, clojure]
----
(-> (dsl/update :t1)
    (dsl/set :name "foo")
    (fmt/get-sql))
;; => "update t1 set name = ?"
----

.Example of update statement with one condition.
[source, clojure]
----
(-> (dsl/update :t1)
    (dsl/set :name "foo")
    (dsl/where ["id = ?" 1])
    (fmt/get-sql))
;; => "update t1 set name = ? where (id = ?)"
----

.Example of update statement using subquery.
[source, clojure]
----
(-> (dsl/update :t1)
    (dsl/set :f1 (-> (dsl/select :f2)
                     (dsl/from :t2)
                     (dsl/where ["id = ?" 2])))
    (fmt/get-sql {:dialect :pgsql}))
;; => "update t1 set f1 = (select f2 from t2 where (id = ?))"
----

.Example of multiple assignation un update statement using subquery.
[source, clojure]
----
(-> (dsl/update :t1)
    (dsl/set (dsl/row (dsl/field :f1)
                      (dsl/field :f2))
             (-> (dsl/select :f3 :f4)
                 (dsl/from :t2)
                 (dsl/where ["id = ?" 2])))
    (fmt/get-sql {:dialect :pgsql}))
;; => "update t1 set (f1, f2) = (select f3, f4 from t2 where (id = ?))"
----

.Example of returning clause used in UPDATE statement.
[source, clojure]
----
(-> (dsl/update :t1)
    (dsl/set :name "foo")
    (dsl/returning :id)
    (fmt/get-sql {:dialect :pgsql}))
;; => "update t1 set name = ? returning id"
----


The DELETE statement
~~~~~~~~~~~~~~~~~~~~

.Simple example of delete statement with one condition
[source, clojure]
----
(-> (dsl/delete :t1)
    (dsl/where "id = 1")
    (fmt/get-sql))
;; => "delete from t1 where (id = 1)"
----


SQL Statements (DDL)
~~~~~~~~~~~~~~~~~~~~

The TRUNCATE statement
^^^^^^^^^^^^^^^^^^^^^^

[source, clojure]
----
(-> (dsl/truncate :table1)
    (fmt/get-sql))
;; => "truncate table table1"
----

The ALTER statement
^^^^^^^^^^^^^^^^^^^

Alter statements are used mainly for add, modify or delete columns from table.

.Add new column
[source, clojure]
----
(-> (dsl/alter-table :t1)
    (dsl/add-column :title :pg/varchar {:length 2 :null false})
    (fmt/get-sql))
;; => "alter table t1 add title varchar(2) not null"
----

.Change type of column
[source, clojure]
----
(-> (dsl/alter-table :t1)
    (dsl/set-column-type :title :pg/varchar {:length 100})
    (fmt/get-sql))
;; => "alter table t1 alter title varchar(100)"
----

.Drop column
[source, clojure]
----
(-> (dsl/alter-table :t1)
    (dsl/drop-column :title :cascade)
    (fmt/get-sql))
;; => "alter table t1 drop title cascade"
----

The DROP statement
^^^^^^^^^^^^^^^^^^

.Drop table example
[source, clojure]
----
(-> (dsl/drop-table :t1)
    (fmt/get-sql))
;; => "drop table t1"
----

Table Expressions
~~~~~~~~~~~~~~~~~

The VALUES() table constructor
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Some databases allow for expressing in-memory temporary tables using a `values()`.

.Select from `values()` example
[source, clojure]
----
(-> (dsl/select :f1 :f2)
    (dsl/from (-> (dsl/values (dsl/row 1 2)
                              (dsl/row 3 4))
                  (dsl/as "t1" "f1" "f2")))
    (fmt/get-sql {:type :inlined}))
;; => "select f1, f2 from (values(1, 2), (3, 4)) as \"t1\" (\"f1\", \"f2\")"
----

WARNING: `suricatta.dsl/row` is defined as macro and only accept literals.

Nested SELECTs
^^^^^^^^^^^^^^

.Using nested select in where clause
[source, clojure]
----
(-> (dsl/select)
    (dsl/from :book)
    (dsl/where (list "book.age = ({0})" (dsl/select-one)))
    (fmt/get-sql))

;; => "select * from book where (book.age = (select 1 as \"one\"))"
----

.Using nested select in from clause
[source, clojure]
----
(-> (dsl/select)
    (dsl/from (-> (dsl/select :f1)
                  (dsl/from :t1)
                  (dsl/as "tt1")))
    (fmt/get-sql))
;; => "select \"tt1\".\"f1\" from (select f1 from t1) as \"tt1\"(\"f1\")"
----

.Using nested select in select fields clauses
[source, clojure]
----
(-> (dsl/select :fullname, (-> (dsl/select (dsl/field "count(*)"))
                               (dsl/from :book)
                               (dsl/where "book.authorid = author.id")
                               (dsl/as-field "books")))
    (dsl/from :author)
    (fmt/get-sql))
;; => "select fullname, (select count(*) from book where (book.authorid = author.id)) "books" from author"
----

How to Contribute?
------------------

Philosophy
~~~~~~~~~~

Five most important rules:

- Beautiful is better than ugly.
- Explicit is better than implicit.
- Simple is better than complex.
- Complex is better than complicated.
- Readability counts.

All contributions to _suricatta_ should keep these important rules in mind.


Procedure
~~~~~~~~~

**suricatta** unlike Clojure and other Clojure contrib libs, does not have many
restrictions for contributions. Just follow the following steps depending on the
situation:

**Bugfix**:

- Fork the GitHub repo.
- Fix a bug/typo on a new branch.
- Make a pull-request to master.

**New feature**:

- Open new issue with the new feature proposal.
- If it is accepted, follow the same steps as "bugfix".


License
~~~~~~~

_suricatta_ is writen from scratch and is licensed under Apache 2.0 license:

----
Copyright (c) 2014 Andrey Antukh <niwi@niwi.be>

Licensed under the Apache License, Version 2.0 (the "License")
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
----

You can see the full license in the LICENSE file located in the root of the project
repo.
